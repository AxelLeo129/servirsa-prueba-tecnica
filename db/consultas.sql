-- Projects Table
CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    code VARCHAR(10) UNIQUE NOT NULL, -- Autogenerated format: P-0001, P-0002...
    name VARCHAR(255) NOT NULL,
    municipality VARCHAR(100) NOT NULL,
    department VARCHAR(100) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL
);

-- Budget Items Table
CREATE TABLE budget_items (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    project_id INT NOT NULL,
    UNIQUE (name, project_id), -- Restriction: unique name within the same project
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- Donations Table
CREATE TABLE donations (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    donor VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
    budget_item_id INT NOT NULL,
    project_id INT NOT NULL,
    FOREIGN KEY (budget_item_id) REFERENCES budget_items(id) ON DELETE CASCADE,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- Purchase Orders Table
CREATE TABLE purchase_orders (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    supplier VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
    budget_item_id INT NOT NULL,
    project_id INT NOT NULL,
    FOREIGN KEY (budget_item_id) REFERENCES budget_items(id) ON DELETE CASCADE,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- (a) El porcentaje de ejecución de fondos para cada proyecto registrado. La ejecución se calcula como el monto total ejecutado (gastado) dentro del total de fondos recibidos por medio de donaciones.
SELECT 
    p.id AS project_id,
    p.code AS project_code,
    p.name AS project_name,
    COALESCE(SUM(d.amount), 0) AS total_received,
    COALESCE(SUM(po.amount), 0) AS total_spent,
    CASE 
        WHEN COALESCE(SUM(d.amount), 0) = 0 THEN 0
        ELSE ROUND((COALESCE(SUM(po.amount), 0) / COALESCE(SUM(d.amount), 1)) * 100, 2)
    END AS execution_percentage
FROM projects p
LEFT JOIN donations d ON p.id = d.project_id
LEFT JOIN purchase_orders po ON p.id = po.project_id
GROUP BY p.id, p.code, p.name
ORDER BY p.id;

-- (b) La disponibilidad de fondos en cada rubro del proyecto “X” (Ejemplo: "Rural Education"), de modo que se muestren todos los rubros del proyecto (incluyendo los que pueden no tener ninguna donación recibida o ninguna orden de compra emitida)
--- Query incorrecta
SELECT 
    bi.id AS budget_item_id,
    bi.name AS budget_item_name,
    COALESCE(SUM(d.amount), 0) AS total_received,
    COALESCE(SUM(po.amount), 0) AS total_spent,
    (COALESCE(SUM(d.amount), 0) - COALESCE(SUM(po.amount), 0)) AS available_funds
FROM budget_items bi
LEFT JOIN donations d ON bi.id = d.budget_item_id AND d.project_id = (SELECT id FROM projects WHERE name = 'Rural Education')
LEFT JOIN purchase_orders po ON bi.id = po.budget_item_id AND po.project_id = (SELECT id FROM projects WHERE name = 'Rural Education')
WHERE bi.project_id = (SELECT id FROM projects WHERE name = 'Rural Education')
GROUP BY bi.id, bi.name
ORDER BY bi.id;

-- Problemas encontrado: 
-- Debido a que las sumas de el total recibido no son correctas, se hizo un análisis de la respuesta anterior, 
-- el problema que se pudo analizar es que primero el LEFT JOIN de donations y el LEFT JOIN de purchase_orders 
-- hacen que los budget_items se repitan a la hora de hacer la suma.

-- Solución:
-- Debido a que la complejidad de la consulta y a que no se encontró la forma de evitar la duplicación e investigar
-- sobre posibles soluciones se elegió la solución basada en CTE (Common Table Expression) que nos permite sacar
-- información de forma separada sin ser una consulta aparte o nueva.

-- Query nuevo (solución)
WITH project_id_cte AS (
    SELECT id 
    FROM projects 
    WHERE name = 'Rural Education'
), donations_cte AS (
    SELECT 
        budget_item_id, 
        SUM(amount) AS total_received
    FROM donations
    WHERE project_id = (SELECT id FROM project_id_cte)
    GROUP BY budget_item_id
), purchase_orders_cte AS (
    SELECT 
        budget_item_id, 
        SUM(amount) AS total_spent
    FROM purchase_orders
    WHERE project_id = (SELECT id FROM project_id_cte)
    GROUP BY budget_item_id
)
SELECT 
    bi.id AS budget_item_id,
    bi.name AS budget_item_name,
    COALESCE(d.total_received, 0) AS total_received,
    COALESCE(po.total_spent, 0) AS total_spent,
    (COALESCE(d.total_received, 0) - COALESCE(po.total_spent, 0)) AS available_funds
FROM budget_items bi
LEFT JOIN donations_cte d ON bi.id = d.budget_item_id
LEFT JOIN purchase_orders_cte po ON bi.id = po.budget_item_id
WHERE bi.project_id = (SELECT id FROM project_id_cte)
ORDER BY bi.id;

-- Explicación:
-- * project_id_cte: Obtiene el id del proyecto, guarda el resultado en project_id_cte (CTE).
-- * donations_cte: Agrupa las donaciones por budget_item y proyecto, suma el total y guarda el resultado en donations_cte (CTE).
-- * purchase_orders_cte: Agrupa los gastos por budget_item y proyecto, suma el total y guarda el resultado en purchase_orders_cte (CTE).
-- * Se une todo en la consulta que se tenía anteriormente cambiando solo los valores respectivos.

-- Conclusión:
-- Evitamos el error de la suma de totales, aumentamos la eficiencia porque si nos damos cuenta ya no se usan SELECT anidados y
-- se entiende de mejor forma la sintaxis de la consulta.